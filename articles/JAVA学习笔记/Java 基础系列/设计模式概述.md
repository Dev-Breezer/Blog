# 设计模式概述

&emsp;

> - 设计模式 一套被**反复使用**、**多数人知晓**、**经过分类编目**的**代码设计经验**的总结（即：设计模式是软件开发人员在**软件开发**过程中面临的**一般问题**的解决方案）

&emsp;

![设计模式分类](/images/Java/设计模式分类.png)


&emsp;

> - 设计模式是基于场景的解决方案,结合实际需求和场景来学习，可以事半功倍
> - 如果某个新场景的解决方案被认可，那我们就可以定义一个新的设计模式

&emsp;

### 单例模式的定义和作用

&emsp;

- 目的：

> 使类的一个对象成为该类系统中的唯一实例

&emsp;

- 定义：

> 一个类有且仅有一个实例，并且自行实例化向整个系统提供

&emsp;

### 设计要点：

&emsp;

> 1. 某个类只能由一个实例对象
> 2. 必须自行创建实例
> 3. 必须自行向整个系统提供这个实例

&emsp;
&emsp;

### 实现：

&emsp;

> 1. 只提供**私有**的构造方法
> 2. 含有一个该类的**静态**私有对象
> 3. 提供一个静态的**公有**方法用于创建、获取静态私有对象

&emsp;

### 单例模式实现的两种代码实现方案：

&emsp;

### 1.饿汉式：对象创建过程中实例化对象

&emsp;

```java
package com.model.singleton;

/**
 *  单例模式之饿汉式
 *  饿汉式：创建对象时直接初始化
 *  特点：运行速度快（即：运行时间短）
 *  缺点：占用空间大
 *  描述：典型的空间换时间模式
 */

public class SingletonOne {

    //  1.创建类中的私有构造方法
    private SingletonOne(){

    }

    //  2.创建该类型私有的静态实例
    private static SingletonOne instance = new SingletonOne();

    //  3.创建公有静态方法返回静态实例对象
    public static SingletonOne getInstance(){
        return instance;
    }
}

```

&emsp;

### 2.懒汉式：静态公有方法中实例化对象

&emsp;

```java
package com.model.singleton;

/**
 * 设计模式之懒汉式
 * 懒汉式：类内实例象创建时并不直接初始化，直到第一次调用 get 方法时，才完成初始化操作（即：什么时候用什么创建实例化对象）
 * 特点：占用空间小，运行时间相较饿汉式而言，时间较长
 * 典型的时间换空间
 */
public class SingletonTwo {

    //  1.创建私有构造方法
    private SingletonTwo(){

    }

    //  2.创建静态的该类实例对象
    private static SingletonTwo instance = null;

    //  3.创建公有的静态方法提供对象实例
    public static SingletonTwo  getInstance(){
        if (instance == null)
            instance = new SingletonTwo();

        return instance;

    }

}
```

&emsp;

### 单例设计模式

&emsp;

优点：
> - 1.在内存中只有一个对象，节省内存空间
> - 2.避免频繁的创建销毁对象，提高性能
> - 3.避免对共享资源的多重占用


&emsp;

缺点：
> - 1.难以扩展
> - 2.实例化对象长期不使用，系统默认为垃圾进行回收，造成对象状态丢失

&emsp;

### **单例设计模式使用场景**

&emsp;

> - 1.创建对象时占用资源过多，但同时又需要用到该类的对象
> - 2.对系统内资源要求统一读写，如读写配置信息
> - 3.当多个实例存在可能引起的程序逻辑错误，如：号码生成器
