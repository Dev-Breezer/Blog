# Java 继承的概念和特点

&emsp;

### 继承的特点：

&emsp;

#### 1. 利用代码复用  
#### 2. 缩短开发周期
#### 3. 继承体现一种类与类之间的关系
#### 4. 使用已存在的类的定义作为基础建立新类

|父类（基类）|  
|:-:|
|子类（派生类）|

#### 5. 新类的定义增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类，**但是不能选择性的继承父类的特征**

&emsp;

### 继承的实现  

&emsp;

编写父类

&emsp;

> - 编写父类

&emsp;

```java
class Animal{
    //  公共的属性和方法
}
```

&emsp;

> - 编写子类、父类

&emsp;

```java
class Dog extends Animal{

}

class Cat extends Animal{

}
```
### 注意：

&emsp;

> - 单继承：一个子类只能继承一个父类

&emsp;

###  方法重写

&emsp;

#### 基类已存在的方法为区别某一子类与基类相同的放，可以使用方法重写

&emsp;

#### 方法重载与方法重写：

> + 方法重载满足以下条件：  
&emsp; 1. 在同一个类中  
&emsp; 2. 方法名相同（与类名），参数列表不同（参数顺序、个数、类型）  
&emsp; 3. 方法返回值、访问修饰符任意  
&emsp; 4. 与方法的参数名无关（即：如果两个方法仅仅只有参数名不一样，也无法构成方法重载）

&emsp;

```java
    //  方法重载
private String sleep(String name){
        return "";

    }
    public void sleep(String name, int month){

    }
    public void sleep(int month, String name){

    }
```

&emsp;

```java
    //  错误:
    //与方法的参数名无关（即：如果两个方法仅仅只有参数名不一样，也无法构成方法重载）  

 public void sleep(int month, String name){

    }
    public void sleep(int name, String month){

    }
```

&emsp;

 #### 方法重写满足以下条件：

 &emsp;

 #### 语法规则：
 #### 注意：

 #### 方法的返回值与访问修饰符允许有变化，但在允许变化的前提下是有条件的?
 
 **_方法名与参数类型、顺序、个数要与父类当中的方法完全一致（即：与父类继承的方法相同）_**
> 1. **在有继承关系的子类中定义**
> 2. **方法名、参数列表相同（参数类型、顺序、个数相同）**
> 4. **访问修饰符,需要大于等于父类的访问范围**
> 5. **与方法的参数名无关（即：对于参数名而言，没有做出限制）**
> 6. **当方法返回值是 void 或基本数据类型时，必须完全相同。 当返回值是自定义的引用类型时，可以是父类或其子类（与父类拥有继承关系的子类）**


&emsp;

 #### 方法重写的特点：

 &emsp;

> 1. 当子类重写父类方法后，子类对象调用的是重写后的方法（即：调用当前子类的方法） 
> 2. 对于重写（覆盖）针对的对象是方法重写而不是属性重写，但我们还是可以在子类中定义同名的属性

&emsp;

### 访问修饰符的分类及作用

&emsp;

> + 私有的 private : 被修饰成员（属性或方法）只能在当前类中被访问
> + 公有的 public : 被修饰成员（属性或方法）可以其它类中任意被访问
> + 受保护的 protected 允许在当前类、同包子类或非子类、跨包子类调用、跨包非子类不允许
> + 默认（不加任何修饰符）允许在当前类、同包子类/非子类调用，跨包子类/非子类不允许调用

&emsp;

![Java 访问修饰符](/images/Java/java访问修饰符.png)

&emsp;

&emsp;

&emsp;

# Java super 关键字的使用

&emsp;

#### 在对方法重写后，当前子类的重写方法的调用优先级最高，但想要调用父类的方法我们需要使用 super 关键字调用

&emsp;

> - **super : 分类对象的引用** 
> - **父类构造不允许被继承、重写 ，但是会影响子类的实例化过程**


#### 继承的初始化顺序

&emsp;

> - **访问修饰符不影响成员加载顺序，跟书写位詈有关**

&emsp;

> - 父类静态成员 -> 子类静态成员 -> 父类对象构造 -> 子类对象构造

&emsp;

### 注意：
**在 Java 的继承当中，我们在子类中没有显式的标注，则子类默认调用无参构造方法**
**可以通过 super() 显式的标注并调用父类中被允许访问的构造方法**
**super() 必须放在子类构造方法有效代码第一行**


### 总结：

> 代表父类引用  
  &emsp; -访问父类成员方法  
 &emsp; &emsp; super.print();  
 &emsp; -访问父类属性  
 &emsp; &emsp; super.name;  
 &emsp; -访问父类构造方法  
 &emsp; &emsp; super();

&emsp;

#### **构造方法调用时，super和this不能同时出现**

&emsp;

### this 与 super 的差异

&emsp;

> this:当前类对象的引用  
&emsp;  
 > -访问当前类的成员方法  
  -访问当前类的成员属性  
  -访问当前类的构造方法  
  -不能在静态方法中使用

&emsp;

> super:父类对象的引用   
&emsp;   
> -访问父类的成员方法  
-访问父类的成员属性  
-访问父类的构造方法  
-不能在静态方法中使用

